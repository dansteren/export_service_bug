# export_service_bug

Candid's [export_service macro](https://docs.rs/candid/latest/candid/macro.export_service.html) doesn't read method names provided to [ic_cdk_macros::query](https://docs.rs/ic-cdk-macros/latest/ic_cdk_macros/attr.query.html).

In this example we write a function in rust called `rust_method` and then expose it to the IC as `candid_method`.

```rust
#[candid::candid_method(query)]
#[ic_cdk_macros::query(name = "candid_method")]
pub fn rust_method() -> bool {
    true
}
```

## Expected Behavior

Calling the `export_service` macro should generate a candid file where the method is named `candid_method`.

## Actual Behavior

Calling the `export_service` macro generates a candid file where the method is named `rust_method`.

## Steps to Reproduce

1. Start the replica: `dfx start --background`
2. Deploy the canister: `dfx deploy`
3. Verify the method is callable as "candid_method": `dfx canister call backend candid_method`
4. Generate the candid file using the export service: `node generate_candid_file.js`
5. Note that src/backend/canister.did now lists `rust_method` instead of `candid_method`.
6. Try to call the canister with "rust_method" as the candid indicates: `dfx canister call backend rust_method`
7. Note that the canister has no query method "rust_method"

> **Note**
> The checked-in version of src/backend/canister.did is the expected output, not what is actually generated by the export service.

## Solution

Dfinity is working to combine the two macros. In the meantime, add a `rename` attribute to the `candid_method` call.

```rust
#[candid::candid_method(query, rename = "candid_method")]
#[ic_cdk_macros::query(name = "candid_method")]
pub fn rust_method() -> bool {
    true
}
```
